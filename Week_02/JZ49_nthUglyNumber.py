class Solution:
    '''
    1,2,3,4,5,6,8,9,10,12..........x(n),x(n+1),x(n+2),x(n+3)....... (n>1)
    我们证明x(n+1),x(n+2),x(n+3) 一定可以分解成为2*x(a),3*x(b),5*x(c)   
    下面采用反证法来证明:
    先讨论一种反面  是否x(n+1),x(n+2),x(n+3) 可以由两个丑因子或者说一个丑因子组成?
    先看一个丑因子的情况 2**2 2**3 2**4 .... 随着指数增大 两个丑数之间的差距就越大 忽略的丑数就
    更多 我们只需要判断前面最紧凑的一部分就行了  前面最紧凑的部分 4,6,8 显然不是三个连续的
    丑数 3,5同理. 所以单个的丑因子 是无法构建出来三个连续的丑数的   (连续的丑数是指 丑数之间没有其他丑数)
    
    再看两个丑因子的情况 两个丑因子有(2,3) (2,5) (3,5) 分别用数列来表示  (下面是他们的丑数列)
    (2,3) = 2 3 4 6 ......  (一个全是由2,3因子构成的丑数列) 一个较大的丑数 必然是一个较小的丑 数*(2,3)丑数因子组成的)
    我对这个数列进行延申 (2,3,4,6)*2 = (4,6,8,12),(2,3,4,6)*3 =(6,9,12,18)  可以看到跨度随着倍数延申了 如果前面不能形成连续的
    x(n+1),x(n+2),x(n+2) 后面  更加不能 1,2,3,4,5,6,8,9,10,12.....有全由2,3组成的连续三丑数吗  有！ 有且仅有一个2,3,4
    前面说了n>1 所以x(n+1)>x2=2  所以2,3也不能构建除连续三个丑数(中间一定有其他丑数)......
    (2,5) (3,5)同理讨论 一样无法构成 

    所以三个连续的丑数必然是由2,3,5 三个丑数构成  (幂函数跨度太大 不可能紧凑) 所以它必须是混合 的  也就对任意连续三丑数
    x(n+1),x(n+2),x(n+3) 可以分解成  2*x(a),3*x(b),5*x(c)  
    '''
    def nthUglyNumber(self, n: int) -> int:
        dp = [1] * n
        a = b = c = 0  
        for i in range(1,n):
# x(n),x(n+1),x(n+2) 可以分解成为 2*x(a),3*x(b),5*x(c)  x(n),x(n+1),x(n+2)是要求的 而x(a),x(b),x(c) 自然是之前已经求出来的  我们不知道x(n)是哪一个 但是它一定是  2*x(a),3*x(b),4*x(c) 中最小的  x(n) = min(2*x(a),3*x(b),4*x(c)) 这是核心表达式找出来了  我们只需要更新a,b,c即可找出所有的x(n)了   其中0=<a,b,c 也就是第i个丑数 与 a,b,c索引相关  
            xn_1,xn_2,xn_3 = 2*dp[a],3*dp[b],5*dp[c]
            dp[i] = min(xn_1,xn_2,xn_3)
# 下面更新索引 不能使用elif  因为存在2*某个丑数 ,3*某个丑数,5*某个丑数相同的情况 出现相同的情况 所以要直接跳过 重复的情况   
            if dp[i] == xn_1:
# 说明是第a个较小的丑数dp[a]与因子(2,3,5) 产生的dp[i]  所以右移a
                a += 1
            if dp[i] == xn_2:
                b+= 1
            if dp[i] == xn_3:
                c += 1
        return dp[-1]